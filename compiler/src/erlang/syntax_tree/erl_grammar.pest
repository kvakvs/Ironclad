// Erlang file contains list of forms
// Each form is either an attribute or a function definition.

// Parse entire modules starting from this rule
module = { module_start_attr ~ form * }
module_start_attr = { "-" ~ "module" ~ "(" ~ atom ~ ")" ~ "." }

// // This consumes entire line which begins with "-<ident>" and ends with ".<newline>"
// entire_attr_as_text = { "-" ~ ident ~ !( "." ~ NEWLINE ) ~ ANY * ~ "." ~ NEWLINE }

// TODO: Consume entire attribute as string and parse separately
// Parse extracted attributes starting from this rule
attr = _ { any_typespec | attribute | attribute_noargs }
attribute_noargs = { "-" ~ ident ~ ( "." | ( "(" ~ ")" ~ "." )) }
attribute = { "-" ~ !"module" ~ ident ~ "(" ~ expr ~ ("," ~ expr)* ~ ")" ~ "." }

form = _{ attr | function_def }

// Function contains of 1 or more clauses, separated by ";" and terminated by "."
// A function clause begins with a name, and a list of match variables in parentheses.
// A function body is an expression (attempted to parse as a comma expression).
function_def = { function_clause ~ (";" ~ function_clause) * ~ "." }

function_clause = {atom ~ "(" ~ bindable_expr? ~ ("," ~ bindable_expr)* ~ ")"
    ~ ("when" ~ guard_expr)? ~ "->"
    ~ expr }

var = { capitalized_ident }

// A bindable expression, used for function arguments and for matching
bindable_expr = { var | "_" | literal }

//----------------------------------------
// Expressions, values, binary and unary operators
//----------------------------------------

// An expression is a tree of values and variables and function calls, but also can be a comma expression (multiple
// expressions, separated by commas and only last one will count as the result, while others just contribute their
// variable values to the scope). And any expression can become a function application (a call) if added the args.
expr = {
    ( application_or_term ~ ( expr_operator ~ application_or_term )* )
}
application_or_term = _{ application | lambda | expr_term }
expr_term = _{ ( "(" ~ expr ~ ")" ) | var | literal | list | tuple }
list = { "[" ~ expr ~ ("," ~ expr)* ~ "]" }
tuple = { "{" ~ expr ~ ("," ~ expr)* ~ "}" }

lambda = { "fun" ~ lambda_function_clause ~ (";" ~ lambda_function_clause) }
lambda_function_clause = { "(" ~ bindable_expr? ~ ("," ~ bindable_expr)* ~ ")"
    ~ ("when" ~ guard_expr)? ~ "->"
    ~ expr }

// Attaches to the end of an expression converting it into a function call
application = {
    ( expr_term ~ application0 ) // optionally followed by empty ()
    | ( expr_term ~ applicationN )
}
application0 = { "(" ~ ")" }

// this will be a solo expr or a comma operator, which we will unwrap into args
applicationN = { "(" ~ expr ~ ")" }

expr_operator = _{
    op_list_append | op_list_subtract
    | op_colon | op_hash | op_unary_ | op_binary1_ | op_binary2_
    | op_cmp | op_andalso | op_orelse | op_assign | op_send
    | op_catch | op_comma
}
op_colon = { ":" }
op_hash = { "#" }

op_unary_ = _{ op_plus | op_minus | op_bnot | op_not }
op_plus = { "+" }
op_minus = { "-" }
op_bnot = { "bnot" }
op_not = { "not" }

op_binary1_ = _{ op_div | op_mul | op_integer_div | op_remainder | op_band | op_and }
op_div = { "/" }
op_mul = { "*" }
op_integer_div = { "div" }
op_remainder = { "rem" }
op_band = { "band" }
op_and = { "and" }

op_binary2_ = _{ op_plus | op_minus | op_bor | op_bxor | op_bsl | op_bsr | op_or | op_xor }
// includes op_plus
// includes op_minus
op_bor = { "bor" }
op_bxor = { "bxor" }
op_bsl = { "bsl" }
op_bsr = { "bsr" }
op_or = { "or" }
op_xor = { "xor" }

op_list_append = { "++" }
op_list_subtract = { "--" }

op_cmp = { op_eq | op_neq | op_lteq | op_lt | op_geq | op_gt | op_hard_eq | op_hard_neq }
op_eq = { "==" }
op_neq = { "/=" }
op_lteq = { "=<" }
op_lt = { "<" }
op_geq = { ">=" }
op_gt = { ">" }
op_hard_eq = { "=:=" }
op_hard_neq = { "=/=" }

op_andalso = { "andalso" }
op_orelse = { "orelse" }
op_assign = { "=" }
op_send = { "!" }
op_catch = { "catch" }
op_comma = { "," }

guard_expr = { expr ~ (guard_separator ~ expr)* }
guard_separator = _{ "," | ";" }

// A literal is any value or constant expression whose result is fully known at compile time
literal = {
    number_float | number_int | atom | string
}

// A number can be integer or float
// Integer can be:
//    - {sign} regular decimal
//    - TODO: N# based integer where N=2..26
// Float can be
//    - {sign} 0.
//    - {sign} .0
//    - TODO: Scientific notation +0.0E+123
number_float = { number_sign? ~ (non_negative_int ~ "." ~ non_negative_int) }
number_int = ${ number_sign? ~ non_negative_int }
number_sign = _{ "S-" | "S+" } // TODO: remove S
non_negative_int = { ASCII_DIGIT+ }

//----------------------------------------
// Strings, atoms, identifiers
//----------------------------------------

string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ string_char* }
string_char = {
    !("\"" | "\\") ~ ANY
    // | "\\" ~ ("\"" | "\\" | "/")
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Parse atom which is either an identifier-like structure or a single 'quoted' string
atom = { ident | quoted_atom }
quoted_atom = _{ "'" ~ quoted_atom_inner ~ "'" }
quoted_atom_inner = @{ quoted_atom_char }
quoted_atom_char = {
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

ident = ${ !keyword ~ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
capitalized_ident = ${ (ASCII_ALPHA_UPPER | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
anycase_ident = ${ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

keyword = _{ "after" | "and" | "andalso" | "band" | "begin"| "bnot" | "bor" | "bsl" | "bsr" | "bxor" | "case"
 | "catch" | "cond" | "div" | "end" | "fun" | "if"| "let" | "not" | "of" | "or"| "orelse" | "receive" | "rem"
 | "try" | "when" | "xor" }

//----------------------------------------
// Type specs, type exports, and other type stuff
//----------------------------------------

any_typespec = _{ fn_spec_attr | new_type_attr | type_export_attr }

// Module, function name, and arity. Module name is allowed in typespecs if equal to the current module
fn_spec_fn_name = { ( ident ~ ":" )? ~ ident }

// Defines a named erlang type, possibly with some type arguments
erl_type = { ident ~ "()" }
typevar = { capitalized_ident }

// A function argument, can be a "TypeVariable" name (default to any()), a "Variable :: type()", or just "type()"
argument_spec = { typevar_spec | typevar | erl_type }
// A comma-separated collection of specced and unspecced function arguments
fn_spec_args = { argument_spec ~ ( "," ~ argument_spec ) * }
// 'when' clause gives types to typevariables used earlier in the typespec
fn_spec_when = { "when" ~ typevar_spec ~ ( ";" ~ typevar_spec )* }
// Gives a type to a variable name or a typevariable (unspecced Capitalized name appearing in a fn_clause_spec)
typevar_spec = { typevar ~ "::" ~ erl_type }
// One function clause, has some arguments, a return type and optional when-part
fn_clause_spec = { "(" ~ fn_spec_args ~ ")" ~ "->" ~ erl_type ~ fn_spec_when? }
// Function spec contains one or multiple clauses, finalized with a period
fn_spec_attr = { "-spec" ~ fn_spec_fn_name ~ fn_clause_spec ~ ( ";" ~ fn_clause_spec )* ~ "." }

new_type_attr = { "-type()." }
type_export_attr = { "-export_type([])." }

//-------
// Misc
//-------

WHITESPACE = _{ WHITE_SPACE }
COMMENT = ${ "%" ~ ( ! NEWLINE ~ ANY )* ~ NEWLINE }
