// Erlang file contains list of forms
// Each form is either an attribute or a function definition.

module = { form * }

module_attr = { "-" ~ "module" ~ "(" ~ atom ~ ")" ~ "." }
attribute_noargs = { "-" ~ ident ~ ( "." | ( "(" ~ ")" ~ "." )) }
attribute = { "-" ~ !"module" ~ ident ~ "(" ~ expr ~ ("," ~ expr)* ~ ")" ~ "." }

form = _{ module_attr | attribute | attribute_noargs | function_def }

// Function contains of 1 or more clauses, separated by ";" and terminated by "."
// A function clause begins with a name, and a list of match variables in parentheses.
// A function body is an expression (attempted to parse as a comma expression).
function_def = { function_clause ~ (";" ~ function_clause) * ~ "." }
function_clause = {atom ~ "(" ~ bindable_expr? ~ ("," ~ bindable_expr)* ~ ")"
    ~ ("when" ~ guard_expr)? ~ "->"
    ~ expr }

var = { capitalized_ident }

// A bindable expression, used for function arguments and for matching
bindable_expr = { var | "_" | literal }

// An expression is a tree of values and variables and function calls, but also can be a comma expression (multiple
// expressions, separated by commas and only last one will count as the result, while others just contribute their
// variable values to the scope). And any expression can become a function application (a call) if added the args.
expr = {
    ( application_or_term ~ ( expr_operator ~ application_or_term )* )
}
application_or_term = _{ application | expr_term }
expr_term = _{ ( "(" ~ expr ~ ")" ) | var | literal | list | tuple }
list = { "[" ~ expr ~ ("," ~ expr)* ~ "]" }
tuple = { "{" ~ expr ~ ("," ~ expr)* ~ "}" }

// Attaches to the end of an expression converting it into a function call
application = {
    ( expr_term ~ application0 ) // optionally followed by empty ()
    | ( expr_term ~ applicationN )
}
application0 = { "(" ~ ")" }

// this will be a solo expr or a comma operator, which we will unwrap into args
applicationN = { "(" ~ expr ~ ")" }

expr_operator = _{
    op_list_append | op_list_subtract
    | op_colon | op_hash | op_unary_ | op_binary1_ | op_binary2_
    | op_cmp | op_andalso | op_orelse | op_assign | op_send
    | op_catch | op_comma
}
op_colon = { ":" }
op_hash = { "#" }

op_unary_ = _{ op_plus | op_minus | op_bnot | op_not }
op_plus = { "+" }
op_minus = { "-" }
op_bnot = { "bnot" }
op_not = { "not" }

op_binary1_ = _{ op_div | op_mul | op_integer_div | op_remainder | op_band | op_and }
op_div = { "/" }
op_mul = { "*" }
op_integer_div = { "div" }
op_remainder = { "rem" }
op_band = { "band" }
op_and = { "and" }

op_binary2_ = _{ op_plus | op_minus | op_bor | op_bxor | op_bsl | op_bsr | op_or | op_xor }
// includes op_plus
// includes op_minus
op_bor = { "bor" }
op_bxor = { "bxor" }
op_bsl = { "bsl" }
op_bsr = { "bsr" }
op_or = { "or" }
op_xor = { "xor" }

op_list_append = { "++" }
op_list_subtract = { "--" }

op_cmp = { op_eq | op_neq | op_lteq | op_lt | op_geq | op_gt | op_hard_eq | op_hard_neq }
op_eq = { "==" }
op_neq = { "/=" }
op_lteq = { "=<" }
op_lt = { "<" }
op_geq = { ">=" }
op_gt = { ">" }
op_hard_eq = { "=:=" }
op_hard_neq = { "=/=" }

op_andalso = { "andalso" }
op_orelse = { "orelse" }
op_assign = { "=" }
op_send = { "!" }
op_catch = { "catch" }
op_comma = { "," }

guard_expr = { expr ~ (guard_separator ~ expr)* }
guard_separator = _{ "," | ";" }

// A literal is any value or constant expression whose result is fully known at compile time
literal = {
    number_float | number_int | atom | string
}

// A number can be integer or float
// Integer can be:
//    - {sign} regular decimal
//    - TODO: N# based integer where N=2..26
// Float can be
//    - {sign} 0.
//    - {sign} .0
//    - TODO: Scientific notation +0.0E+123
number_float = { number_sign? ~ (ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+) }
number_int = ${ number_sign? ~ ASCII_DIGIT+ }
number_sign = _{ "S-" | "S+" } // TODO: remove S

string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ string_char* }
string_char = {
    !("\"" | "\\") ~ ANY
    // | "\\" ~ ("\"" | "\\" | "/")
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Parse atom which is either an identifier-like structure or a single 'quoted' string
atom = { ident | quoted_atom }
quoted_atom = _{ "'" ~ quoted_atom_inner ~ "'" }
quoted_atom_inner = @{ quoted_atom_char }
quoted_atom_char = {
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

ident = ${ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
capitalized_ident = ${ (ASCII_ALPHA_UPPER | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
anycase_ident = ${ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

// // Take all characters which are not newline, even with whitespaces
// text = ${ (!NEWLINE ~ ANY)+ ~ NEWLINE }
//
// // erl_comment = ${ "%" ~ (!NEWLINE ~ ANY)*  }
//
WHITESPACE = _{ WHITE_SPACE }
COMMENT = ${ "%" ~ ( ! NEWLINE ~ ANY )* ~ NEWLINE }
