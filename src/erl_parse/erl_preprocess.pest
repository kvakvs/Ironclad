// Split an ERL source into macro definitions, conditional compile directives and everything else

file = { file_item* }
file_item = _{ (pp_directive | text | string) ~ NEWLINE }

pp_directive = _{ pp_directive_include | pp_directive_module | pp_directive_include_lib | pp_generic }
directive_ending = _{ ")" ~ "." }

// Particular case: Include directive -include("path").
pp_directive_include = { "-" ~ "include" ~ "(" ~ string ~ directive_ending }

pp_directive_module = { "-" ~ "module" ~ "(" ~ atom ~ directive_ending }

// Particular case: Include directive -include_lib("path").
pp_directive_include_lib = { "-" ~ "include_lib" ~ "(" ~ string ~ directive_ending }

// Generic case: Any directive with 'ident' as a name and some comma separated args
pp_generic = { "-" ~ ident ~ pp_generic_args? ~ "." }
pp_generic_args = _{ "(" ~ pp_generic_arg? ~ ("," ~ pp_generic_arg)* ~ ")" }
pp_generic_arg = { ( !( "," | ")" ) ~ ANY )+ }

string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ string_char }
string_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Parse atom which is either an identifier-like structure or a single 'quoted' string
atom = { ident | quoted_atom }
quoted_atom = _{ "'" ~ quoted_atom_inner ~ "'" }
quoted_atom_inner = @{ quoted_atom_char }
quoted_atom_char = {
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

ident = { (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }

text = { ANY+ }

WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "%" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }
