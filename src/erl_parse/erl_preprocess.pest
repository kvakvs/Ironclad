// Split an ERL source into macro definitions, conditional compile directives and everything else

file = {
    // optional because empty lines should match something too, like just a newline
    file_item*
}
file_item = _{ pp_directive | text | string }

pp_directive = _{
    ( pp_include | pp_include_lib
    | pp_define | pp_undef
    | pp_if | pp_elif
    | pp_ifdef | pp_ifndef | pp_else | pp_endif )
}

// Particular case: Include directive -include("path").
pp_include = { "-" ~ "include" ~ "(" ~ string ~ ")" ~ "." }

// pp_module = { "-" ~ "module" ~ "(" ~ atom ~ ")" ~ "." }

// Particular case: Include directive -include_lib("path").
pp_include_lib = { "-" ~ "include_lib" ~ "(" ~ string ~ ")" ~ "." }

pp_define = { "-" ~ "define" ~ "(" ~ anycase_ident ~ "," ~ pp_directive_remaining_text ~ pp_directive_tail }
pp_undef = { "-" ~ "undef" ~ "(" ~ anycase_ident ~ ")" ~ "." }

// Conditional directive, if symbol is defined
pp_ifdef = { "-" ~ "ifdef" ~ "(" ~ anycase_ident ~ ")" ~ "." }

// Conditional directive, if symbol is not defined
pp_ifndef = { "-" ~ "ifndef" ~ "(" ~ anycase_ident ~ ")" ~ "." }

// Conditional directive, if symbolic expression evaluates true
pp_if = { "-" ~ "if" ~ "(" ~ pp_directive_remaining_text ~ ")" ~ "." }

// Conditional directive, replaces last condition on the condition stack
pp_elif = { "-" ~ "elif" ~ "(" ~ pp_directive_remaining_text ~ ")" ~ "." }

// Allows both -else(). and -else.
pp_else = { "-" ~ "else" ~ ( "(" ~ ")" )? ~ "." }

// Allows both -endif(). and -endif.
pp_endif = { "-" ~ "endif" ~ ( "(" ~ ")" )? ~ "." }

// Consumes everything till ").<CRLF>" or till a comment
pp_directive_remaining_text = ${ (! pp_directive_tail ~ ANY)+ }
pp_directive_tail = _{ ")" ~ "." ~ (NEWLINE | "%") }

// Generic case: Any directive with 'ident' as a name and some comma separated args
// pp_generic = { "-" ~ ident ~ pp_generic_args? ~ "." }
// pp_generic_args = _{ "(" ~ pp_generic_arg? ~ ("," ~ pp_generic_arg)* ~ ")" }
// pp_generic_arg = { ( !( "," | ")" ) ~ ANY )+ }

string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ string_char }
string_char = {
    !("\"" | "\\") ~ ANY
    // | "\\" ~ ("\"" | "\\" | "/")
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Parse atom which is either an identifier-like structure or a single 'quoted' string
atom = { ident | quoted_atom }
quoted_atom = _{ "'" ~ quoted_atom_inner ~ "'" }
quoted_atom_inner = @{ quoted_atom_char }
quoted_atom_char = {
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

ident = ${ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
anycase_ident = ${ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

// Take all characters which are not newline, even with whitespaces
text = ${ (!NEWLINE ~ ANY)+ ~ NEWLINE }

// erl_comment = ${ "%" ~ (!NEWLINE ~ ANY)*  }

WHITESPACE = _{ WHITE_SPACE }
COMMENT = ${ "%" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }
