// Erlang file contains list of forms
// Each form is either an attribute or a function definition.

forms = { module_attr ~ form* }
form = _{ attribute | attribute_noargs | function_def }

attribute_noargs = { "-" ~ ident ~ "." }

module_attr = { "-" ~ "module" ~ "(" ~ atom ~ ")" ~ "." }

attribute = { "-" ~ !"module" ~ ident ~ "(" ~ expr? ~ ("," ~ expr)* ~ ")" ~ "." }

// Function contains of 1 or more clauses, separated by ";" and terminated by "."
// A function clause begins with a name, and a list of match variables in parentheses.
// A function body is an expression, often a comma expression.
function_def = { function_clause ~ (";" ~ function_clause) * ~ "." }
function_clause = {atom ~ "(" ~ match_var? ~ ("," ~ match_var)* ~ ")"
    ~ ("when" ~ guard_expr)? ~ "->"
    ~ expr }

var = _{ capitalized_ident }

match_var = {
    var
    | "_"
    //| binary_match_pattern
    | literal
    }

// An expression is a tree of values and variables and function calls, but also can be separated by commas and only
// last one will count as the result, while others just contribute their variable values to the scope.
expr = { expr_item ~ ("," ~ expr_item)* }
expr_item = _{ var | literal }
guard_expr = { expr ~ (guard_separator ~ expr)* }
guard_separator = _{ "," | ";" }

// A literal is any value or constant expression whose result is fully known at compile time
literal = _{
    number_float | number_int | atom | string
    // | list | tuple
    }

// A number can be integer or float
// Integer can be:
//    - {sign} regular decimal
//    - TODO: N# based integer where N=2..26
// Float can be
//    - {sign} 0.
//    - {sign} .0
//    - TODO: Scientific notation +0.0E+123
number_float = { number_sign? ~ ((ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT*) | (ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+)) }
number_int = ${ number_sign? ~ non_negative_int }
number_sign = _{ "-" | "+" }
non_negative_int = _{ ASCII_DIGIT+ }

string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ string_char* }
string_char = {
    !("\"" | "\\") ~ ANY
    // | "\\" ~ ("\"" | "\\" | "/")
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Parse atom which is either an identifier-like structure or a single 'quoted' string
atom = { ident | quoted_atom }
quoted_atom = _{ "'" ~ quoted_atom_inner ~ "'" }
quoted_atom_inner = @{ quoted_atom_char }
quoted_atom_char = {
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

ident = ${ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
capitalized_ident = ${ (ASCII_ALPHA_UPPER | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
anycase_ident = ${ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

// // Take all characters which are not newline, even with whitespaces
// text = ${ (!NEWLINE ~ ANY)+ ~ end_line }
//
// // erl_comment = ${ "%" ~ (!NEWLINE ~ ANY)*  }
//
WHITESPACE = _{ WHITE_SPACE }
COMMENT = ${ "%" ~ (!NEWLINE ~ ANY)* ~ end_line }

end_line = _{ NEWLINE | EOI }