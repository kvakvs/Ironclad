// Split an ERL source into macro definitions, conditional compile directives and everything else

file = {
    // optional because empty lines should match something too, like just a newline
    file_item*
}
file_item = _{ pp_directive | text | string }

pp_directive = _{
    ( pp_include | pp_include_lib
    | pp_define | pp_define_fun | pp_undef
    | pp_if | pp_elif
    | pp_ifdef | pp_ifndef | pp_else | pp_endif
    | pp_error | pp_warning
    )
}

// Particular case: Include directive -include("path").
pp_include = { "-" ~ "include" ~ "(" ~ string ~ ")" ~ "." }

// Create a compiler error or a compiler warning
pp_error = { "-" ~ "error" ~ "(" ~ string ~ ")" ~ "." }
pp_warning = { "-" ~ "warning" ~ "(" ~ string ~ ")" ~ "." }

// Particular case: Include directive -include_lib("path").
pp_include_lib = { "-" ~ "include_lib" ~ "(" ~ string ~ ")" ~ "." }

// Defines a NAME to be equal to SOME TEXT
pp_define = { "-" ~ "define" ~ "(" ~ anycase_ident ~ "," ~ pp_directive_remaining_text ~ pp_directive_tail }

// Like the one before, but with args: -define(NAME(A, B, ...), Value).
pp_define_fun = {
    "-" ~ "define" ~ "(" ~ anycase_ident ~ pp_args ~ ","
    ~ pp_directive_remaining_text ~ pp_directive_tail
}
pp_args = { "(" ~ anycase_ident? ~ ("," ~ anycase_ident)*  ~ ")" }

pp_undef = { "-" ~ "undef" ~ "(" ~ anycase_ident ~ ")" ~ "." }

// Conditional directive, if symbol is defined
pp_ifdef = { "-" ~ "ifdef" ~ "(" ~ anycase_ident ~ ")" ~ "." }

// Conditional directive, if symbol is not defined
pp_ifndef = { "-" ~ "ifndef" ~ "(" ~ anycase_ident ~ ")" ~ "." }

// Conditional directive, if symbolic expression evaluates true
pp_if = { "-" ~ "if" ~ "(" ~ pp_directive_remaining_text ~ ")" ~ "." }

// Conditional directive, replaces last condition on the condition stack
pp_elif = { "-" ~ "elif" ~ "(" ~ pp_directive_remaining_text ~ ")" ~ "." }

// Allows both -else(). and -else.
pp_else = { "-" ~ "else" ~ ( "(" ~ ")" )? ~ "." }

// Allows both -endif(). and -endif.
pp_endif = { "-" ~ "endif" ~ ( "(" ~ ")" )? ~ "." }

// Consumes everything till ").<CRLF>" or till a comment
pp_directive_remaining_text = ${ (! pp_directive_tail ~ ANY)+ }
// Tail is ")." that is not inside a string or quoted string
pp_directive_tail = _{ ")" ~ "." }
// pp_directive_tail = _{ !( string | quoted_atom ) ~ ")." ~ (NEWLINE | "%") }

string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ string_char* }
string_char = {
    !("\"" | "\\") ~ ANY
    // | "\\" ~ ("\"" | "\\" | "/")
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// Parse atom which is either an identifier-like structure or a single 'quoted' string
atom = { ident | quoted_atom }
quoted_atom = _{ "'" ~ quoted_atom_inner ~ "'" }
quoted_atom_inner = @{ quoted_atom_char }
quoted_atom_char = {
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

ident = ${ (ASCII_ALPHA_LOWER | "_") ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
anycase_ident = ${ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

// Take all characters which are not newline, even with whitespaces
text = ${ (!NEWLINE ~ ANY)+ ~ end_line }

// erl_comment = ${ "%" ~ (!NEWLINE ~ ANY)*  }

WHITESPACE = _{ WHITE_SPACE }
COMMENT = ${ "%" ~ (!NEWLINE ~ ANY)* ~ end_line }

end_line = _{ NEWLINE | EOI }